import shutil
import subprocess
from collections.abc import Iterable
from pathlib import Path

import pandas as pd

REPO_URL = "https://github.com/Institut-zdravotnych-analyz/OSN-Algoritmus-MS.git"
REPO_DIR = "OSN-Algoritmus-MS"


def run_algorithm(
    input_path: Path, output_path: Path, flags: Iterable[str] = []
) -> Path:
    """
    Run the algorithm with specified input file and flags.

    Args:
        input_path: Path to the input file
        flags: flags to pass to the algorithm

    Returns:
        Path to the output file generated by the algorithm
    """

    setup_py_exists = (Path(REPO_DIR) / "setup.py").exists()
    pyproject_toml_exists = (Path(REPO_DIR) / "pyproject.toml").exists()
    is_pkg = setup_py_exists or pyproject_toml_exists

    if is_pkg:
        venv_dir = Path(REPO_DIR) / "venv_dir"
        print("Installing package")
        if not venv_dir.exists():
            create_venv = ["python", "-m", "venv", str(venv_dir)]
            subprocess.run(create_venv, cwd=REPO_DIR, check=True, capture_output=True)
        install_pkg = [str(venv_dir / "bin" / "pip"), "install", "."]
        subprocess.run(install_pkg, cwd=REPO_DIR, check=True, capture_output=True)
        run_algo = [
            str(venv_dir / "bin" / "python"),
            "main.py",
            str(input_path),
            str(output_path),
            ' '.join(flags),
        ]
    else:
        output_path = input_path.with_stem(f"{input_path.stem}_output")
        run_algo = ["python", "main.py", str(input_path), f"-{''.join(flags)}"]

    print("Running algorithm")
    subprocess.run(run_algo, cwd=REPO_DIR, check=True)
    return output_path


def compare_outputs(
    output_file_a: Path,
    output_file_b: Path,
    version_a: str,
    version_b: str,
) -> pd.DataFrame:
    """
    Compare outputs from two different versions of the algorithm.

    Args:
        output_file_a: Path to the output file from version A
        output_file_b: Path to the output file from version B
        version_a: Identifier for version A
        version_b: Identifier for version B

    Returns:
        DataFrame containing only the rows where the outputs differ
    """
    df_a = pd.read_csv(output_file_a, sep=";")
    df_b = pd.read_csv(output_file_b, sep=";")

    merged_df = pd.merge(
        df_a,
        df_b[["id", "ms"]],
        on="id",
        suffixes=[f"_{version_a}", f"_{version_b}"],
    )

    diff_rows = merged_df[merged_df[f"ms_{version_a}"] != merged_df[f"ms_{version_b}"]]
    return diff_rows


def run_and_compare(
    commit_a: str,
    commit_b: str,
    input_path: str | Path,
    flags: Iterable[str],
    *,
    remove_created_files: bool = True,
) -> pd.DataFrame:
    """
    Run the algorithm with two different versions and compare their outputs.
    Warning: when local=True, the algorithm loads changes done in
    test/compare_versions/OSN-Algoritmus-MS.

    Args:
        commit_a: Commit of the first version to run
        commit_b: Commit of the second version to run
        input_file: Path to the input file
        flags: List of flags to pass to the algorithm
        remove_created_files: Whether to remove temporary files after comparison
        local: If True, skip fetching from remote and use only local repository

    Returns:
        DataFrame with algorithm outputs containing only the rows where the outputs
        differ
    """
    input_path = Path(input_path).resolve()

    if not Path(REPO_DIR).exists():
        print("Cloning repo")
        clone_repo = ["git", "clone", REPO_URL]
        subprocess.run(clone_repo, check=True, capture_output=True)

    print("Fetching repo")
    fetch_repo = ["git", "-C", REPO_DIR, "fetch", "origin"]
    subprocess.run(fetch_repo, check=True, capture_output=True)

    created_files = []
    differences = None
    try:
        if commit_a is None:
            print(f"Running local version ")
            from OSN_Algoritmus.core import grouper_ms

            output_a_path = "  "
            grouper_ms(input_path, output_a_path, resolve_flags(flags))
        else:
            print(f"Running version A: {commit_a}")
            checkout_version_a = ["git", "-C", REPO_DIR, "checkout", commit_a]
            subprocess.run(checkout_version_a, check=True, capture_output=True)

            versioned_input_a_path = input_path.with_stem(
                f"{input_path.stem}_{commit_a}"
            )
            shutil.copy(input_path, versioned_input_a_path)
            created_files.append(versioned_input_a_path)

            output_a_path = run_algorithm(versioned_input_a_path, flags)
            created_files.append(output_a_path)

        print(f"Running version B: {commit_b}")
        checkout_version_b = ["git", "-C", REPO_DIR, "checkout", commit_b]
        subprocess.run(checkout_version_b, check=True, capture_output=True)

        versioned_input_b_path = input_path.with_stem(f"{input_path.stem}_{commit_b}")
        shutil.copy(input_path, versioned_input_b_path)
        created_files.append(versioned_input_b_path)

        output_b_path = run_algorithm(versioned_input_b_path, flags)
        created_files.append(output_b_path)

        differences = compare_outputs(output_a_path, output_b_path, commit_a, commit_b)
    finally:
        if remove_created_files:
            print(f"Cleaning up files for {commit_a} and {commit_b}")
            for file_path in created_files:
                try:
                    if file_path.exists():
                        file_path.unlink()
                except Exception as e:
                    print(f"Warning: Failed to remove {file_path}: {e}")

    return differences
