"""Module for comparing outputs of two versions of the algorithm."""

import shutil
import subprocess
from collections.abc import Iterable
from pathlib import Path

import pandas as pd

from OSN_Algoritmus.core import setup_parser

REPO_URL = "https://github.com/Institut-zdravotnych-analyz/OSN-Algoritmus-MS.git"
CLONED_REPO_DIR = Path("OSN-Algoritmus-MS")


def run_algorithm_from_commit(commit: str, input_path: Path, flags: Iterable[str] = []) -> Path:
    """Run the algorithm with specified input file and flags.

    Args:
        commit: Commit hash/tag/branch to run
        input_path: Path to the input file
        flags: flags to pass to the algorithm

    Returns:
        Path to the output file generated by the algorithm

    """
    print(f"Running version: {commit}")
    checkout_version_a = ["git", "-C", CLONED_REPO_DIR, "checkout", commit]
    subprocess.run(checkout_version_a, check=True, capture_output=True)

    setup_py_exists = (CLONED_REPO_DIR / "setup.py").exists()
    pyproject_toml_exists = (CLONED_REPO_DIR / "pyproject.toml").exists()
    is_pkg = setup_py_exists or pyproject_toml_exists

    if is_pkg:
        venv_dir = CLONED_REPO_DIR / "venv_dir"
        print("Installing package")
        if not venv_dir.exists():
            create_venv = ["python", "-m", "venv", str(venv_dir)]
            subprocess.run(create_venv, cwd=CLONED_REPO_DIR, check=True, capture_output=True)
        install_pkg = [str(venv_dir / "bin" / "pip"), "install", "."]
        subprocess.run(install_pkg, cwd=CLONED_REPO_DIR, check=True, capture_output=True)
        output_path = input_path.with_stem(f"{input_path.stem}_{commit}_output")
        run_algo = [
            str(venv_dir / "bin" / "python"),
            "main.py",
            str(input_path),
            str(output_path),
            *flags,
        ]
    else:
        run_algo = ["python", "main.py", str(input_path), *flags]
        output_path = input_path.with_stem(f"{input_path.stem}_output")

    print(f"Running algorithm with command: {' '.join(run_algo)}")
    subprocess.run(run_algo, cwd=CLONED_REPO_DIR, check=True)
    return output_path


def compare_outputs(output_file_a: Path, output_file_b: Path, version_a: str, version_b: str) -> pd.DataFrame:
    """Compare outputs from two different versions of the algorithm.

    Args:
        output_file_a: Path to the output file from version A
        output_file_b: Path to the output file from version B
        version_a: Identifier for version A
        version_b: Identifier for version B

    Returns:
        DataFrame containing only the rows where the outputs differ

    """
    df_a = pd.read_csv(output_file_a, sep=";")
    df_b = pd.read_csv(output_file_b, sep=";")

    merged_df = df_a.merge(df_b[["id", "ms"]], on="id", suffixes=[f"_{version_a}", f"_{version_b}"])

    return merged_df[merged_df[f"ms_{version_a}"] != merged_df[f"ms_{version_b}"]]


def run_and_compare(
    commit_a: str,
    input_path: Path | str,
    commit_b: str | None = None,
    flags: list[str] | None = None,
    *,
    remove_repo: bool = False,
) -> pd.DataFrame:
    """Run the algorithm with two different versions and compare their outputs.

    Args:
        commit_a: Commit of the first version to run
        input_path: Path to the input file
        commit_b: Commit of the second version to run. If None, run currently installed version
        flags: List of flags to pass to the algorithm, for example ["-vnd"]
        remove_repo: If True, remove the cloned repository after running the algorithm
    Returns:
        DataFrame with algorithm outputs containing only the rows where the outputs
        differ

    """
    input_path = Path(input_path).resolve()

    if not CLONED_REPO_DIR.exists():
        print("Cloning repo")
        clone_repo = ["git", "clone", REPO_URL]
        subprocess.run(clone_repo, check=True, capture_output=True)

    fetch_repo = ["git", "-C", CLONED_REPO_DIR, "fetch", "origin"]
    subprocess.run(fetch_repo, check=True, capture_output=True)

    created_files = []
    differences = None
    try:
        checkout_version_a = ["git", "-C", CLONED_REPO_DIR, "checkout", commit_a]
        subprocess.run(checkout_version_a, check=True, capture_output=True)

        output_a_path = run_algorithm_from_commit(commit_a, input_path, flags)
        created_files.append(output_a_path)
        if commit_b is None:
            print("Running local version")
            from OSN_Algoritmus.core import grouper_ms

            output_b_path = input_path.with_stem(f"{input_path.stem}_local")

            parsed_args = setup_parser().parse_args(flags)
            grouper_ms(
                input_path,
                output_b_path,
                vsetky_vykony_hlavne=parsed_args.vsetky_vykony_hlavne,
                vyhodnot_neuplne_pripady=parsed_args.vyhodnot_neuplne_pripady,
                ponechaj_duplicity=parsed_args.ponechaj_duplicity,
            )
            created_files.append(output_b_path)
        else:
            print(f"Running version B: {commit_b}")
            checkout_version_b = ["git", "-C", CLONED_REPO_DIR, "checkout", commit_b]
            subprocess.run(checkout_version_b, check=True, capture_output=True)

            output_b_path = run_algorithm_from_commit(commit_b, input_path, flags)
            created_files.append(output_b_path)

        differences = compare_outputs(output_a_path, output_b_path, commit_a, commit_b or "local")
    finally:
        if remove_repo:
            print(f"Removing cloned repository at {CLONED_REPO_DIR.resolve()}")
            shutil.rmtree(CLONED_REPO_DIR)

        print("Cleaning up created files")
        for file_path in created_files:
            if file_path.exists():
                file_path.unlink()

    return differences
