"""Module for comparing outputs of two versions of the algoritmus."""

import dataclasses
import logging
import shutil
import subprocess
import sys
from pathlib import Path

import pandas as pd

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

REPO_URL = "https://github.com/Institut-zdravotnych-analyz/OSN-Algoritmus-MS.git"
CLONED_REPO_DIR = Path("OSN-Algoritmus-MS")


def run_algoritmus_from_ref(ref: str, input_path: Path, flags: list[str] | None = None) -> Path:
    """Run the algoritmus with specified input file and flags after checking out a specific git ref.

    Args:
        ref: Git ref to run algoritmus from
        input_path: Path to the input file
        flags: flags to pass to the algoritmus

    Returns:
        Path to the output file generated by the algoritmus

    """
    flags = flags or []
    logger.info("Checking out and running version from ref: %s with flags: %s", ref, flags)

    if not CLONED_REPO_DIR.exists():
        logger.info("Cloning repo")
        clone_repo = ["git", "clone", REPO_URL]
        subprocess.run(clone_repo, check=True, capture_output=True)
    fetch_ref_cmd = ["git", "-C", str(CLONED_REPO_DIR), "fetch", "origin", ref]
    subprocess.run(fetch_ref_cmd, check=True, capture_output=True)
    checkout_ref_cmd = ["git", "-C", str(CLONED_REPO_DIR), "checkout", ref]
    subprocess.run(checkout_ref_cmd, check=True, capture_output=True)

    setup_py_exists = (CLONED_REPO_DIR / "setup.py").exists()
    pyproject_toml_exists = (CLONED_REPO_DIR / "pyproject.toml").exists()
    is_pkg = setup_py_exists or pyproject_toml_exists

    if is_pkg:
        venv_dir = CLONED_REPO_DIR / "venv_dir"
        logger.info("Installing package")
        if not venv_dir.exists():
            create_venv = [sys.executable, "-m", "venv", str(venv_dir)]
            subprocess.run(create_venv, cwd=CLONED_REPO_DIR, check=True, capture_output=True)
        install_pkg = [str(venv_dir / "bin" / "pip"), "install", "."]
        subprocess.run(install_pkg, cwd=CLONED_REPO_DIR, check=True, capture_output=True)
        output_path = input_path.with_stem(f"{input_path.stem}_{ref}_output")
        run_algo = [str(venv_dir / "bin" / "python"), "main.py", str(input_path), str(output_path), *flags]
    else:
        run_algo = [sys.executable, "main.py", str(input_path), *flags]
        output_path = input_path.with_stem(f"{input_path.stem}_output")

    logger.info("Running algoritmus with command: %s", " ".join(run_algo))
    subprocess.run(run_algo, cwd=CLONED_REPO_DIR, check=True)
    return output_path


def run_local_version(input_path: Path, flags: list[str] | None) -> Path:
    """Run the locally installed version of the algoritmus."""
    from OSN_Algoritmus.core import grouper_ms, setup_parser

    flags = flags or []
    logger.info("Running local version with flags: %s", flags)

    flags_str = "_".join(flags)
    output_path = input_path.with_stem(f"{input_path.stem}_local_{flags_str}")
    parser = setup_parser(vsetky_vykony_hlavne=True, vyhodnot_neuplne_pripady=True, ponechaj_duplicity=True)
    args = parser.parse_args(flags)

    grouper_ms(
        input_path,
        output_path,
        vsetky_vykony_hlavne=args.vsetky_vykony_hlavne,
        vyhodnot_neuplne_pripady=args.vyhodnot_neuplne_pripady,
        ponechaj_duplicity=args.ponechaj_duplicity,
    )
    return output_path


def compare_outputs(output_file_a: Path, output_file_b: Path, version_a: str, version_b: str) -> pd.DataFrame:
    """Compare outputs from two different versions of the algoritmus.

    Args:
        output_file_a: Path to the output file from version A
        output_file_b: Path to the output file from version B
        version_a: Identifier for version A
        version_b: Identifier for version B

    Returns:
        DataFrame containing only the rows where the outputs differ

    """
    df_a = pd.read_csv(output_file_a, sep=";")
    df_b = pd.read_csv(output_file_b, sep=";")

    merged_df = df_a.merge(df_b[["id", "ms"]], on="id", suffixes=[f"_{version_a}", f"_{version_b}"])

    return merged_df[merged_df[f"ms_{version_a}"] != merged_df[f"ms_{version_b}"]]


@dataclasses.dataclass
class VersionConfig:
    """Configuration for a single version run.

    Args:
        version: Either "local" to use the locally installed version, or a git ref
        flags: List of command line flags to pass to the algoritmus

    """

    version: str
    flags: list[str] = dataclasses.field(default_factory=list)


def run_and_compare(
    input_path: Path | str, version_a_cfg: VersionConfig, version_b_cfg: VersionConfig, *, remove_repo: bool = True
) -> pd.DataFrame:
    """Run the algoritmus with two different versions and compare their outputs.

    Args:
        input_path: Path to the input file
        version_a_cfg: Configuration for the first version
        version_b_cfg: Configuration for the second version
        remove_repo: If True, remove the cloned repository after running the algoritmus
    Returns:
        DataFrame with algoritmus outputs containing only the rows where the outputs
        differ

    """
    if version_a_cfg == version_b_cfg:
        msg = "Version configurations are identical"
        raise ValueError(msg)

    input_path = Path(input_path).resolve()
    needs_repo_cleanup = (version_a_cfg.version != "local" or version_b_cfg.version != "local") and remove_repo

    created_files = []

    try:
        if version_a_cfg.version == "local":
            output_a_path = run_local_version(input_path, version_a_cfg.flags)
        else:
            output_a_path = run_algoritmus_from_ref(version_a_cfg.version, input_path, version_a_cfg.flags)
        created_files.append(output_a_path)

        if version_b_cfg.version == "local":
            output_b_path = run_local_version(input_path, version_b_cfg.flags)
        else:
            output_b_path = run_algoritmus_from_ref(version_b_cfg.version, input_path, version_b_cfg.flags)
        created_files.append(output_b_path)

        version_a_label = "_".join([version_a_cfg.version, str(version_a_cfg.flags)])
        version_b_label = "_".join([version_b_cfg.version, str(version_b_cfg.flags)])
        differences = compare_outputs(output_a_path, output_b_path, version_a_label, version_b_label)

    finally:
        if needs_repo_cleanup:
            logger.info("Removing cloned repository at %s", CLONED_REPO_DIR.resolve())
            shutil.rmtree(CLONED_REPO_DIR)

        logger.info("Cleaning up created files")
        for file_path in created_files:
            if file_path and file_path.exists():
                file_path.unlink()

    return differences
